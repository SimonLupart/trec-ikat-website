{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Last updated: August 22, 2023 </p> <p> See the official TREC iKAT repository for tools and code related to the track</p>"},{"location":"#introduction-to-trec-interactive-knowledge-assistance-track","title":"Introduction to TREC Interactive Knowledge Assistance Track","text":"<p>Voice-based assistant interactions are now widespread, with a recent Comscore report showing that over 20% of homes in America own a smart speaker. Furthermore, the recent announcement of assistant-enabled smart glasses from leading tech companies continues this trend towards real-world interaction. However, despite current assistants' ability to perform well-defined simple actions, their ability to support information seeking in conversations continues to be limited.</p> <p>Conversational Information Seeking (CIS) is an established and important research direction. It is of interest to the broad research community within information retrieval, such as ranking, summarizing and question answering (QA), as well as for natural language processing and dialogue systems communities.</p> <p>The TREC Interactive Knowledge Assistance Track (iKAT) builds on the experience of four successful years of TREC Conversational Assistance Track (CAsT), where the key focus of iKAT is on researching and developing collaborative information seeking conversational agents which can tailor and personalize their response based on what they learn about and from the user.</p> <p>The fourth year of CAsT aimed to add more conversational elements to the interaction streams, by introducing mixed initiatives (clarifications, and suggestions) to create multi-path, multi-turn conversations for each topic. TREC iKAT evolves CAsT into a new track to signal this new trajectory. iKAT aims to focus on supporting multi-path, multi-turn, multi-perspective conversations, i.e., for a given topic, the direction and the conversation that evolves depends not only on the prior responses but also on the user (and their background/perspective/context/etc). As different personas undertake various topics, systems need to build and develop a picture of who the user is, in order to best address their information needs. Put another way, iKAT focuses on system understanding of user knowledge and information needs in accordance to the available context.</p> <p>Shield: </p> <p>All data associated with this work is licensed and released under a Creative Commons Attribution-ShareAlike 4.0 International License.</p> <p></p>"},{"location":"#track-coordinators","title":"Track Coordinators","text":"<p>Mohammad Aliannejadi, University of Amsterdam, The Netherlands. Dr. Aliannejadi is an Assistant Professor at the IRLab (formerly known as ILPS), the University of Amsterdam in The Netherlands. His research is in modeling user information needs with a focus on recommender systems, unified (meta) search, and conversational systems. </p> <p>Zahra Abbasiantaeb, University of Amsterdam, The Netherlands. Zahra is a Ph.D. student at the IRLab supervised by Dr. Aliannejadi. She is working on conversational search and recommendation. Earlier, she has also worked on patent reference mining. Zahra obtained her masters in AI from the Amirkabir University of Technology with a focus on Question Answering systems.</p> <p>Shubham Chatterjee, University of Glasgow, Scotland. Dr. Chatterjee is a Research Associate in the Glasgow Representation and Information Learning (GRILL) Lab, part of the Glasgow Information Retrieval group. The goal of his research is to design intelligent search systems which would one day respond to a user's open-ended and complex information needs with a complete answer instead of a ranked list of results.</p> <p>Jeff Dalton, University of Glasgow, Scotland. Dr. Dalton is a Senior Lecturer (Associate Professor) at the Department of Computing Science, University of Glasgow. He is also the PI for the GRILL Lab. His research focuses on new methods for machine understanding of language and text data using deep neural networks and entity knowledge graphs for improving information seeking applications.</p> <p>Leif Azzopardi, University of Strathclyde, Scotland. Dr. Azzopardi is an Associate Professor in Artifical Intelligence and Data Science within the Departement of Computer and Information Sciences at the University of Strathclyde. He is the PI for the Interaction Lab (i-lab) which specializes in developing, evaluating and modelling information rich and information intensive applications and agents.</p>"},{"location":"#contact","title":"Contact","text":"<ul> <li>Twitter: @trec_ikat</li> <li>Email: trec.ikat.ai@gmail.com</li> <li>Google Groups: trec-ikat@googlegroups.com</li> <li>Slack: ikat-2023</li> </ul>"},{"location":"#announcements","title":"Announcements","text":"<ul> <li> <p> New! Baselines released. Guidelines updated. Demo released.</p> </li> <li> <p>Additional data released for the participants. See the data section.</p> </li> <li> <p>Train topics released! See the data section of the website.</p> </li> <li> <p>Sample topics released! See the data section of the website. </p> </li> <li> <p>Guidelines released!</p> </li> </ul>"},{"location":"data/","title":"Datasets and Resources","text":""},{"location":"data/#topics-for-ikat-year-1","title":"Topics for iKAT Year 1","text":"File Description 2023_train_topics.json Train topics in JSON format. 2023_test_topics.json Test topics in JSON format."},{"location":"data/#addtional-data","title":"Addtional Data","text":"File Description 2023_train_topics_psg_text.jsonl Text of provenance passages in the train topics. 2023_test_topics_psg_text.jsonl Text of provenance passages in the test topics. 2023_top_1000_query_results.zip This zip file has queries from both training and testing topics, saved in <code>queries_train.txt</code> and <code>queries_test.txt</code> respectively. The results from the iKAT searcher (<code>BM25</code> using manually resolved queries) are saved in the <code>query_results_train</code> and <code>query_results_test</code> folders. Each result file, with up to 1000 results, corresponds to a query based on line numbers, starting from zero. For instance, the results for the first query in <code>queries_train.txt</code> can be found in <code>query_results_train/query_results_000.txt</code>. In each result file, every line shows the <code>ClueWeb22 ID</code> followed by the <code>URL</code>."},{"location":"data/#baseline-runs","title":"Baseline Runs","text":"<p>Below, we provide two baseline runs. </p> <ul> <li>Method.<ul> <li><code>BM25+RM3</code> (Pyserini default) as the initial retrieval (denoted by <code>ret_bm25_rm3</code> in the file name) method to retrieve 1000 passages per query (denoted by <code>k_1000</code>).</li> <li>The query in each turn was re-written using: <ol> <li>The context, and </li> <li>The top-3 relevant PTKB statements (denoted by <code>num_ptkb_3</code> in the file name).</li> </ol> </li> </ul> </li> <li>Query re-writing. In all cases, the re-written query was construted by appending the relevant PTKB statements to the (manually or automatically) resolved query.</li> <li>Response generation. A response was generated using the top-3 passages retrieved with the re-written query (denoted by <code>num_psg_3</code> in the file name). We use the <code>T5</code> model <code>mrm8488/t5-base-finetuned-summarize-news</code> available on HuggingFace for this purpose. </li> <li>For automatic runs. <ul> <li>The relevant PTKB statements were determined automatically by re-ranking the statements using <code>SentenceTransformers</code>, specifically, the model <code>cross-encoder/ms-marco-MiniLM-L-6-v2</code> available on HuggingFace.</li> <li>The query was re-written automatically using the <code>castorini/t5-base-canard</code> model available on HuggingFace.</li> </ul> </li> <li>For manual runs. <ul> <li>The relevant PTKB statements provided in the <code>ptkb_provenance</code> field were used. </li> <li>The manually re-written query provided in the <code>resolved_utterance</code> field was used.</li> </ul> </li> </ul> File Run Type ret_bm25_rm3--type_automatic--num_ptkb_3--k_1000--num_psg_3.official.run.json Automatic ret_bm25_rm3--type_manual--num_ptkb_3--k_1000--num_psg_3.official.run.json Manual"},{"location":"data/#document-collection-trec-ikat-2023-clueweb22-b","title":"Document Collection: TREC iKAT 2023 ClueWeb22-B","text":"<p>The collection distribution is being handled directly by CMU and not the iKAT organizers. Please follow these steps to get your data license ASAP:</p> <ul> <li>Sign the license form available on the ClueWeb22 project web page.</li> <li>Send the form to CMU for approval (jlm4@andrew.cmu.edu)</li> </ul> <p>Please give enough time to the CMU licensing office to accept your request. A download link will be sent to you by the ClueWeb22 team at CMU.</p> <p>Note. </p> <ul> <li>CMU requires a signature from the organization (i.e., the university or company), not an individual who wants to use the data. This can slow down the process at your end too. So, it\u2019s useful to start the process ASAP.</li> <li>If you already have an accepted license for ClueWeb22, you don\u2019t need a new form. Please let us know if that\u2019s the case.</li> </ul>"},{"location":"data/#additional-resources","title":"Additional Resources","text":"<p>We provide the following additional resources for the teams:</p>"},{"location":"data/#trec-ikat-2023-clueweb22-b-passage-collection","title":"TREC iKAT 2023 ClueWeb22-B Passage Collection","text":"<p>We provide a segmented version of the TREC iKAT 2023 ClueWeb22-B Document collection available from CMU in two formats: <code>JSONL</code> and <code>TrecWeb</code>. </p> <p>In case you have segmented the document collection yourself, you may check whether your segments match ours using the <code>tsv</code> file of passage hashes provided. </p> <ul> <li>Passage collection in <code>JSONL</code> format.<ul> <li>These files contain passages in the form <code>{\"id\": \"[passage id]\", \"contents\": \"[passage text]\", \"url\": \"[ClueWeb22 document URL]\"}</code></li> <li>Passage IDs are structured as: <code>doc_id:passage_number</code></li> <li>Total download size is approximately 31 GB.</li> <li>Total number of passages is 116,838,987</li> </ul> </li> <li> <p>Passage collection in <code>TrecWeb</code> format.</p> <ul> <li>Format as shown on website.</li> <li>Total download size is approximately 31 GB</li> </ul> </li> <li> <p>Passage hashes.</p> <ul> <li><code>tsv</code> file containing MD5 hashes of passage texts.</li> <li>The <code>.tsv</code> file has this format: <code>doc_id   passage_number    passage_MD5</code></li> <li>Total download size is 2.2 GB</li> </ul> </li> </ul>"},{"location":"data/#sparse-lucene-passage-index","title":"Sparse Lucene Passage Index","text":"<p>We also provide a sparse Lucene index generated from the <code>JSONL</code> passage files above using Pyserini. The files form a single <code>.tar.bz2</code> archive split into sections for simpler downloading due to the overall size. To extract the archive, once downloaded, you must combine each of the sections in name order back into a single file: </p> <pre><code>cat ikat_2023_passage_index.tar.bz2.part* &gt; ikat_203_passage_index.tar.bz2\n</code></pre> <p>Total download size is approximately 150 GB</p>"},{"location":"data/#how-do-i-access-these-resources","title":"How do I access these resources?","text":"<p>Each team should use a URL of <code>https://ikattrecweb.grill.science/&lt;team_name&gt;</code> to access the files. The page will ask for a userID and password. Enter the login details which you obtained from the iKAT organizers. You should see a page which lists each type of data and has links to the individual files listed above, along with their checksum files.</p> <p>NOTE: </p> <ul> <li>Currently, these teams can access this URL: <code>MLIA</code>,  <code>TREMA_UNH</code> and <code>Nota</code> . Please send us a message privately via slack or through the email and we will share the login details with you.</li> <li>Other teams: You have shared IPs in the <code>10.x.x.x</code> range which is for private networks, so we need another IP from you. Can you please share another suitable IP with us so that we may configure the above download link to work for you?</li> </ul>"},{"location":"data/#ikat-searcher","title":"iKAT Searcher","text":"<p>iKAT Searcher is a simple tool developed to help with creating the topics for iKAT. The tool allows topic developers to visually assess the behaviour of a retrieval system, ultimately making it easier to develop challenging, but interesting, topics for the Track. You can interact with the system here. See the GitHub repository.</p>"},{"location":"data/#additional-data-from-trec-cast","title":"Additional Data from TREC CAsT","text":"<p>We provide the data from previous years' TREC CAsT below. The iKAT topics are similar, with the addition of the Personal Text Knowledge Base. For more information on TREC CAsT, see the website and read the overview papers [2019] [2020] [2021] [2022]</p> <p>Note. TREC CAsT did not include a PTKB but you can be creative and modify the data according to your needs. Also, TREC CAsT used different collections (Wikipedia, KILT, MS MARCO, etc.) at different stages. iKAT is using a subset of the recently released ClueWeb22-B. </p>"},{"location":"data/#cast-year-4-2022","title":"CAsT Year 4 (2022)","text":"File Description 2022_automatic_evaluation_topics_tree_v1.0.json Contains each conversation tree (topic) with an automatic rewrite generated for each user utterance. 2022_evaluation_topics_turn_ids.json Contains each conversation tree (topic) with the resolved query for each user utterance. 2022_evaluation_topics_tree_v1.0.json Contains all ids that responses/ranked passages need to be returned for. 2022_evaluation_topics_flattened_duplicated_v1.0.json Contains all possible conversation paths across all the conversation trees."},{"location":"data/#cast-year-3-2021","title":"CAsT Year 3 (2021)","text":"File Description 2021_automatic_evaluation_topics_v1.0.json 25 primary evaluation topics in JSON format. Variant: Automatic 2021_manual_evaluation_topics_v1.0.json 25 primary evaluation topics in JSON format. Variant: Manual 2021qrels.txt Qrels file for passage ranking task."},{"location":"data/#cast-year-2-2020","title":"CAsT Year 2 (2020)","text":"File Description 2020_automatic_evaluation_topics_v1.0.json 25 primary evaluation topics in JSON format. Variant: Automatic 2020_manual_evaluation_topics_v1.0.json 25 primary evaluation topics in JSON format. Variant: Manual 2020qrels.txt Qrels file for passage ranking task."},{"location":"data/#cast-year-1-2019","title":"CAsT Year 1 (2019)","text":"File Description train_topics_v1.0.json 30 example training topics in JSON format. evaluation_topics_v1.0.json 50 evaluation topics in JSON format. 2019qrels.txt Official evaluation qrels file for passage ranking task. train_qrels.txt Limited (incomplete) training judegements for 5 topics (approximately 50 turns). The judgments are graded on a three point scale (2 very relevant, 1 relevant, and 0 not relevant)."},{"location":"demo/","title":"TREC iKAT 2023: Getting Started","text":""},{"location":"demo/#objective","title":"Objective","text":"<p>To help you get started, we (the iKAT organizers) have put together this guide. In this demo, we'll explore and build the components of a simple iKAT system. These components include:</p> <ul> <li>Query Rewriter</li> <li>Passage Retriever, and</li> <li>Response Generator</li> </ul>"},{"location":"demo/#system-architecture","title":"System Architecture","text":"<p>The diagram above shows how the components of our system interact.</p> <p>Given a query, conversation context, and the PTKB of the user, our system's Query Rewriter reformulates the query to resolve ambiguity. Next, the Passage Retriever uses the reformulated query to retrieve the top-K candidate passages from an index. Finally, the Response Generator uses the top-N of the K retrieved passages to generate a coherant response. The output of our system is a response along with the provenance relevant passages used to construct the response for the input query, based on the conversation context.</p>"},{"location":"demo/#setup","title":"Setup","text":"<p>Before putting our system together, let's download the topics and the demo collection.</p>"},{"location":"demo/#trec-ikat-2023-simple-english-wikipedia-passage-collection","title":"TREC iKAT 2023 Simple English Wikipedia Passage Collection","text":"<p>Downloading and processing the entire TREC iKAT 2023 ClueWeb22-B passage collection is not possible on Colab. Moreover, it requires a licenece to use. For this demo, we will use Simple English Wikipedia. Compared to the full English wikipedia, it has only about 170k articles. The iKAT organizers have preprocessed the articles and created a passage collection for you to use. This collection is in a <code>jsonl</code> format. An example record from the collection is shown below:</p> <pre><code>{\n    \"id\": \"simplewiki:Ted%20Cassidy:0\",\n    \"contents\": \"Ted Cassidy (July 31, 1932 - January 16, 1979) was an American actor. He was best known for his roles as Lurch and Thing on \\\"The Addams Family\\\".\",\n    \"title\": \"Ted Cassidy\",\n    \"wiki_id\": \"9822\"\n}\n</code></pre> <p>Each record in this collection contains the following fields:</p> <ol> <li><code>id</code>: The passage id is a combination of (1) the string \"simplewiki:\", (2) the encoded title of the Wikipedia page, and (3) the passage number. This is similar to the iKAT 2023 passage id format (doc_id:passage_number) </li> <li><code>contents</code>: The text of the passage.</li> <li><code>title</code>: The title of the Wikipedia page to which this passage belongs.</li> <li><code>wiki_id</code>: The Wikipedia page ID of the Wikipedia page to which this passage belongs. These IDs are unique and will never change</li> </ol> <p>Note. As this collection is a toy collection meant for demo purposes, the quality of results we obtain in this tutorial may be affected.</p> <pre><code>!pip install gdown\n</code></pre> <pre><code>!echo \"Creating target directory..\"\n!mkdir -p ikat_demo\n!mkdir -p ikat_demo/collection\n\nimport gdown\n# The Google Drive file ID and the destination path\nurl = 'https://drive.google.com/uc?id=1touBjwkPByH69utT9_sevr5nYT0TTZ2M'\noutput = '/content/ikat_demo/collection/simplewiki-2020-11-01.passages.jsonl'\ngdown.download(url, output, quiet=False)\n\nurl = 'https://drive.google.com/uc?id=1zPSiAqLmbx9QFGm6walnuMUl7xoJmRB7'\noutput = '/content/ikat_demo/test.json'\ngdown.download(url, output, quiet=False)\n</code></pre>"},{"location":"demo/#creating-a-bm25-index","title":"Creating a BM25 Index","text":"<p>Now, we'll use the Pyserini information retrieval toolkit to build a sparse index for the collection we just downloaded. Pyserini provides APIs for our indexing needs and supports both sparse and dense retrieval. Alternatively, you may also use PyTerrier.</p> <p>First, let's install Pyserini and its dependcies.</p> <pre><code>!pip install pyserini\n!pip install faiss-cpu\n</code></pre> <p>Pyserini provides ingestors for document collections in many different formats. The simplest, however, is the following JSON format:</p> <pre><code>{\n  \"id\": \"doc1\",\n  \"contents\": \"this is the contents.\"\n}\n</code></pre> <p>The collection to be used with Pyserini must be in a <code>jsonl</code> format, where each line is a <code>json</code> record structured as above. The preprocessed collection that we provide is already in a <code>jsonl</code> format.</p> <pre><code>!python -m pyserini.index.lucene \\\n  --collection JsonCollection \\\n  --input  '/content/ikat_demo/collection/' \\\n  --index '/content/ikat_demo/index' \\\n  --generator DefaultLuceneDocumentGenerator \\\n  --threads 8 \\\n  --storePositions --storeDocvectors --storeRaw\n</code></pre> <p>To check that our new sparse index works, let's try searching with it. The code below loads the index and searches for the query <code>global warming</code>.</p> <pre><code>from pyserini.search.lucene import LuceneSearcher\n\nsearcher = LuceneSearcher('ikat_demo/index')\nquery = 'global warming'\nhits = searcher.search(query)\n\nfor i in range(len(hits)):\n    print(f'{i+1:2} {hits[i].docid:4} {hits[i].score:.5f}')\n</code></pre> <p>Let's see the contents of the best ranking document.</p> <pre><code>import json\nbest_ranked_doc = searcher.doc(hits[0].docid)\nparsed_doc = json.loads(best_ranked_doc.raw())\nparsed_doc['contents']\n</code></pre>"},{"location":"demo/#query-rewriting","title":"Query Rewriting","text":"<p>iKAT topics mimic real-world dialogue phenomena. As a result, utterances within topics become increasingly ambiguous as the topic unfolds. On their own, these utterances likely won't return good candidates from our index, so we need to reformulate them using information from prior turns in the topic.</p> <p>Let's examine the utterances in a topic to demonstrate the need for query rewriting. As an example, we will examine a segment from the iKAT 2023 test topic on \"Finding a diet\" conversation.</p> <pre><code>{\n    \"turn_id\": 1,\n    \"utterance\": \"Hey, Assistant! I am wondering what to cook for dinner tonight for my family.\",\n    \"resolved_utterance\": \"Hey, Assistant! I am wondering what to cook for dinner tonight for my family.\",\n    \"response\": \"Hey there! There are many healthy and delicious recipes you could try! For example, a stir-fry with lean proteins like chicken or tofu and a variety of colorful vegetables is always a good option. Or you could try making a Mediterranean quinoa salad with cucumbers, tomatoes, feta cheese, and a light lemon vinaigrette. Baked salmon with a side of roasted vegetables is also a great choice.\",\n},\n{\n    \"turn_id\": 2,\n    \"utterance\": \"Nah, we had salmon just two days ago. But the Mediterranean dish that you mentioned sounds interesting, could you provide the recipe for that?\",\n    \"resolved_utterance\": \"Nah, we had salmon just two days ago. But the Mediterranean quinoa salad sounds interesting, can you provide the recipe for the Mediterranean quinoa salad?\",\n    \"response\": \"Ah, I see. Of course! Here's a simple recipe for Mediterranean Quinoa Salad. The ingredients you need are 1 cup quinoa, 2 cups water, 1/4 cup extra-virgin olive oil, 2 limes, juiced, 2 teaspoons ground cumin, 1 teaspoon salt, 1/2 teaspoon red pepper flakes (optional), 1 1/2 cups halved cherry tomatoes, 1 cucumber, diced, 1/2 cup chopped fresh mint, 1/2 cup feta cheese. Instructions: Bring quinoa and water to a boil in a saucepan. Reduce heat to medium-low, cover, and simmer until quinoa is tender and water has been absorbed, 10 to 15 minutes. Set aside to cool. In a large bowl, whisk olive oil, lime juice, cumin, salt, and red pepper flakes together to create the dressing. In the bowl with the dressing, mix in quinoa, tomatoes, cucumber, and mint. Stir until well mixed. Top with feta cheese before serving. Enjoy!\"\n},\n{\n    \"turn_id\": 3,\n    \"utterance\": \"That's great, thanks! But I'm thinking of reducing the amount of oil in the dressing. Any suggestions?\",\n    \"resolved_utterance\": \"That's great, thanks! But I'm thinking of reducing the amount of oil in the salad dressing. Any suggestions?\",\n    \"response\": \"Certainly! You can reduce the amount of oil by using more lime juice or adding some water. Alternatively, you could substitute some of the oil with a different kind of liquid like vinegar. This should maintain a good balance between tartness and the need for oil as an emulsifier. Which of these do you think works the best for you?\"\n},\n{\n    \"turn_id\": 4,\n    \"utterance\": \"Thanks! My children don't like vinegar, so I would probably go with lime juice. Can I also use butter instead?\",\n    \"resolved_utterance\": \"Thanks! My children don't like vinegar, so I would probably go with lime juice. Can I also butter instead of oil in the Mediterranean Quinoa Salad?\",\n    \"response\": \"Butter can be substituted for vegetable oil in some dishes, but not always. Butter is a solid fat, while vegetable oil is liquid, so they have different effects on the consistency and texture of the food. Butter is also higher in calories and lower in trans fats than vegetable oil. If you want to use butter instead of vegetable oil, you may need to adjust the quantity, melt it down, and let it cool a bit. For example, 1 cup of butter equals 7/8 cup of vegetable oil.\"\n},\n{\n    \"turn_id\": 5,\n    \"utterance\": \"I see, thanks! What are some cheese substitutes?\",\n    \"resolved_utterance\": \"I see, thanks! What are some substitutes for cheese in the Mediterranean Quinoa Salad?\",\n    \"response\": \"I can suggest some alternatives for feta cheese. One option is to use a lower fat cheese like mozzarella. Another is to use a plant-based cheese substitute, if you're open to vegan options. You could also try adding a bit of nutritional yeast for a cheese-like flavor with less fat and more protein.\"\n},\n{\n    \"turn_id\": 6,\n    \"utterance\": \"Can you compare the first two?\",\n    \"resolved_utterance\": \"Can you compare mozzarella with plant-based cheese?\",\n    \"response\": \"Mozzarella cheese is a dairy product derived from milk and produced in a wide range of flavors. It comprises fat, usually from the milk of cows, buffalo, goats, or sheep. On the other hand, vegan cheese is a non-dairy, plant-based product. Vegan cheese is 100 percent animal-free cheese and is made using vegetable proteins. The ingredients of vegan cheese include soy, nuts, cashews, and vegetable oils (such as coconut oil). Vegan cheese is made using a process similar to traditional cheese making-without the animal milk. During the process, the plant proteins are separated using bacteria. Then the ingredients, such as oils and thickeners, are added to achieve the desired cheese-like consistency.\"\n},\n{\n    \"turn_id\": 7,\n    \"utterance\": \"Which of these is suitable for me?\",\n    \"resolved_utterance\": \"Which of mozzarella and vegan cheese is suitable for me?\",\n    \"response\": \"Based on the nutritional facts, mozzarella can be considered safe for lactose-intolerant people to eat, but be aware that the type of mozzarella you buy may not help reduce your symptoms. This is because many types of processed and packaged mozzarella also contain whey powder or casein - two other forms of dairy which are high in lactose. However, mozzarella has almost no lactose. Just one ounce of cheese provides around 0.3 grams of lactose. Vegan cheese is also a good alternative for lactose-intolerant people. Vegan cheeses are 100 percent animal-free and made using vegetable proteins. There are many different types of vegan cheese available, including vegan mozzarella. So, both mozzarella and vegan cheese can be suitable for lactose-intolerant people. It depends on your personal preference and dietary needs.\"\n},\n</code></pre> <p>This topic starts with a question regarding selecting a diet. If we isolate <code>Turn 6</code> from the rest of the conversation and use it for search, we would likely get minimal, if any, results.</p> <p>Now, let's see how a query rewriter helps.</p> <p>We'll use a <code>T5</code> query rewriter from <code>HuggingFace</code>. It is finetuned on the <code>CANARD</code> dataset but works effectively on iKAT queries.</p> <pre><code># Load model and tokenizer from HuggingFace\nfrom transformers import AutoTokenizer, AutoModelForSeq2SeqLM\nimport torch\n\ndevice = \"cuda\" if torch.cuda.is_available() else \"cpu\"\nrewriter = AutoModelForSeq2SeqLM.from_pretrained(\"castorini/t5-base-canard\").to(device).eval()\nrewriter_tokenizer = AutoTokenizer.from_pretrained(\"castorini/t5-base-canard\")\n</code></pre> <p>The model rewrites an utterance using that utterance and all previous utterances and system responses as input. The utterance and previous turn utterances and system responses should be separated by <code>|||</code> when building the input to the model.</p> <p>Let's read the <code>json</code> data file and load the turns.</p> <pre><code>with open('/content/ikat_demo/test.json', 'r') as f:\n    topics = json.load(f)\n</code></pre> <p>Next, we write a small function to extract the context.</p> <p>The provided Python function, <code>extract_context</code>, extracts a sequence of utterances and responses up to a given <code>turn_id</code> from a JSON data structure. Here's a breakdown:</p> <ol> <li> <p>Purpose: Extracts a series of utterances and responses up to a specified turn from a given JSON data based on the provided <code>number</code>.</p> </li> <li> <p>Parameters:</p> <ul> <li><code>json_data</code>: A list of dictionaries, where each dictionary represents a conversation that has a unique number and contains a series of turns.</li> <li><code>number</code>: The unique identifier for a specific conversation in the JSON data.</li> <li><code>turn_id</code>: A specified turn up to which the utterances and responses will be extracted.</li> </ul> </li> <li> <p>Process:</p> <p>a. Locate Conversation: Loops through the <code>json_data</code> to find the dictionary with the given <code>number</code>.</p> <p>b. Error Handling: If no dictionary with the given <code>number</code> is found, it returns a message indicating so.</p> <p>c. Extracting Text: Loops through the turns within the found conversation and appends the utterances and responses up to the <code>turn_id</code> to a list.</p> <p>d. Context Formation: Concatenates the extracted utterances and responses using \"|||\" as a separator to form the context.</p> </li> <li> <p>Output: A tuple containing:</p> <ul> <li>The current <code>utterance</code> for the provided <code>turn_id</code>.</li> <li>The <code>context</code>, which is the sequence of utterances and responses up to the given <code>turn_id</code>, concatenated with \"|||\".</li> </ul> </li> </ol> <pre><code>def extract_context(json_data, number, turn_id):\n    # Find the correct dictionary with the given number\n    data = None\n    for item in json_data:\n        if item['number'] == number:\n            data = item\n            break\n\n    # If we couldn't find the data for the given number\n    if not data:\n      print(\"No data found for the given number.\")\n      return \"No data found for the given number.\", None\n\n    # Extract the utterance and response values\n    texts = []\n    current_utterance = \"\"\n    for turn in data['turns']:\n        if turn['turn_id'] &lt; turn_id:\n            texts.append(turn['utterance'])\n            texts.append(turn['response'])\n        elif turn['turn_id'] == turn_id:\n            current_utterance = turn['utterance']\n            texts.append(current_utterance)\n\n    # Join the texts with \"|||\" separator\n    context = '|||'.join(texts)\n\n    return current_utterance, context\n</code></pre> <p>Now we can use this function to extract the context for a given topic <code>number</code> and <code>turn_id</code> in the topic.</p> <pre><code>number_to_search = \"10-1\"\nturn_id_to_search = 6\nutterance, context = extract_context(topics, number_to_search, turn_id_to_search)\nprint(f\"Raw Utterance: {utterance}\")\nprint(f\"Turn Context: {context}\")\n</code></pre> <p>NOTE: When building context this way, there's a risk that the input can become too lengthy for subsequent interactions, especially in extended discussions. For handling this, you can experiment with various context truncation methods. A straightforward strategy is to eliminate earlier turn utterances and responses if the input size surpasses the model's token limit.</p> <p>Now, let's rewrite the query using our model.</p> <pre><code>def rewrite_query(context: str, model, tokenizer, device) -&gt; str:\n  tokenized_context = tokenizer.encode(context, return_tensors=\"pt\").to(device)\n  output_ids = model.generate(\n      tokenized_context,\n      max_length=200,\n      num_beams=4,\n      repetition_penalty=2.5,\n      length_penalty=1.0,\n      early_stopping=True\n  ).to(device)\n\n  rewrite = tokenizer.decode(output_ids[0], skip_special_tokens=True)\n  return rewrite\n</code></pre> <pre><code>rewrite = rewrite_query(context, rewriter, rewriter_tokenizer, device)\nprint(f\"Raw Utterance: {utterance}\")\nprint(f\"Query Rewrite: {rewrite}\")\n</code></pre> <p>Hmm, that didn't really help! \ud83d\ude1e The rewriter did expand the query but with the wrong information!</p>"},{"location":"demo/#expanding-the-context-using-relevant-ptkb-statements","title":"Expanding the Context using Relevant PTKB Statements","text":"<p>One major difference between iKAT and CAsT is the presence of the Personal Text Knowledge Base (PTKB). In the first year, we are providing the PTKB as a dictionary of statements about the user. Each PTKB defines a user's profile and controls how the system should respond to the user. For the example conversation above, the PTKB, as provided in the test data, is as below.</p> <pre><code>{\n    \"1\": \"I want to know about healthy cooking techniques.\",\n    \"2\": \"I am lactose intolerant.\",\n    \"3\": \"I'm looking for a speaker set to match my TV.\",\n    \"4\": \"I'm willing to drive a long distance to find a cheaper TV.\",\n    \"5\": \"I'm hoping to find some offers and discounts for TV.\",\n    \"6\": \"I like to eat fruits and vegetables.\",\n    \"7\": \"I don't read much.\",\n    \"8\": \"I want to cook healthy and tasty recipes for my family.\",\n    \"9\": \"I am on a diet and prefer low-calorie food.\",\n    \"10\": \"I want to know about the nutritional value of the ingredients I use.\",\n    \"11\": \"I'm looking for a new TV to replace my current one.\",\n    \"12\": \"I want a TV that is okay for light and size of my living room.\"\n},\n</code></pre> <p>Above, we re-wrote the query using the context. But for a more persoanlized conversation, one approach to query rewriting could be to use the PTKB statements in the query reformulation process.</p> <p>To incorporate the PTKB into the system, we must answer two questions:</p> <ol> <li>What are the relevant PTKB statements for the current turn?</li> <li>How do we use these relevant PTKB statements?</li> </ol>"},{"location":"demo/#question-1-what-are-the-relevant-ptkb-statements-for-the-current-turn","title":"Question 1: What are the relevant PTKB statements for the current turn?","text":"<p>In a <code>manual</code> run, you may use the <code>ptkb_provenance</code> fields. This field was manually populated by the iKAT topic developers and provides a straightforward way to identify relevant PTKB statements for the given turn utterance. However, a more difficult (and perhaps interesting) exercise is to automatically identify relevant PTKB statements for the given turn.</p> <p>One easy-to-implement (and probably good) solution is to use <code>BERT</code> embeddings. Specifially, we can use <code>SentenceTransformers</code></p> <p><code>SentenceTransformers</code> is a Python framework designed for sentence, text, and image embeddings. the foundational work on this was presented in the paper titled Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks.</p> <p>This tool enables computation of sentence and text embeddings in over 100 languages. You can then use cosine similarity, for instance, to identify sentences of similar meanings. It's particularly valuable for semantic text similarity, semantic searching, and paraphrase detection.</p> <p>Built on PyTorch and Transformers, the framework boasts a vast array of pre-trained models optimized for diverse tasks. Moreover, fine-tuning your models is a breeze.</p> <p>We are going to use the <code>CrossEncoder</code> model from <code>SentenceTransformers</code> to identify the relevant PTKB statements. Specifically, we are going to re-rank the PTKB statements based on the current utterance.</p> <p>A <code>CrossEncoder</code>-based re-ranker can significantly enhance the end results for users. In this approach, both the query and a potential document are fed into the transformer network concurrently. The network then produces a score between 0 and 1, signifying the document's relevance to the query.</p> <p>The strength of a <code>CrossEncoder</code> lies in its superior performance, stemming from its ability to execute attention operations across both the query and the document.</p> <p>We will use <code>cross-encoder/ms-marco-MiniLM-L-6-v2</code> model from HuggingFace that scores the query and all retrieved passages for their relevancy.</p> <p>For a complete introduction to using cross encoders and retrieval and reranking, see this notebook.</p> <p>First, we need to install the <code>SentenceTransformers</code> library</p> <pre><code>!pip install sentence-transformers\n</code></pre> <p>Next, we write a small function that will rerank the PTKB statements for the given query.</p> <p>The provided Python function, <code>get_ptkb_statements</code>, compares statements from the PTKB with a query to determine their similarity. Here's a step-by-step explanation of the function:</p> <ol> <li> <p>Purpose: The function aims to return the top <code>num_ptkb</code> statements from the PTKB that are most similar to the given <code>query</code>.</p> </li> <li> <p>Parameters:</p> <ul> <li><code>query</code>: The user's input or question.</li> <li><code>num_ptkb</code>: The number of PTKB statements to return.</li> <li><code>ptkb</code>: A dictionary of the PTKB statements.</li> <li><code>reranker</code>: A model that predicts the similarity score between two texts.</li> </ul> </li> <li> <p>Process:</p> <p>a. Calculate Similarity Scores: For each statement in the PTKB, it computes a similarity score with the <code>query</code> using the <code>reranker</code>. The score is between 0 and 1, with 1 being highly similar.</p> <p>b. Pair Statements with Scores: The statements from the PTKB are paired with their respective similarity scores.</p> <p>c. Sort Pairs: The pairs are then sorted in descending order based on their similarity scores.</p> <p>d. Extract Statements: From the sorted pairs, the actual statements are extracted.</p> <p>e. Return Top Statements: The top <code>num_ptkb</code> statements are then concatenated into a single string and returned.</p> </li> <li> <p>Output: A string containing the top <code>num_ptkb</code> statements from the PTKB that are most similar to the given <code>query</code>, separated by spaces.</p> </li> </ol> <pre><code>def get_ptkb_statements(query, num_ptkb, ptkb, reranker):\n    # Find the similarity of PTKB statements with the given query\n    similarity_scores = [reranker.predict([[query, ptkb_statement]])[0] for ptkb_statement in ptkb.values()]\n\n    # Pair each statement with its similarity score\n    statement_score_pairs = list(zip(list(ptkb.values()), similarity_scores))\n\n    # Sort the pairs based on the similarity scores in descending order\n    sorted_pairs = sorted(statement_score_pairs, key=lambda x: x[1], reverse=True)\n\n    # Extract the sorted responses\n    sorted_ptkb_statements = [pair[0] for pair in sorted_pairs]\n\n    # Return required number of PTKB statements\n    return ' '.join(sorted_ptkb_statements[:num_ptkb])\n</code></pre> <p>Now, let's use this function to find the top relevant PTKB statements for a given turn.</p> <pre><code>query = \"Can you compare the first two?\"\nptkb = {\n    \"1\": \"I want to know about healthy cooking techniques.\",\n    \"2\": \"I am lactose intolerant.\",\n    \"3\": \"I'm looking for a speaker set to match my TV.\",\n    \"4\": \"I'm willing to drive a long distance to find a cheaper TV.\",\n    \"5\": \"I'm hoping to find some offers and discounts for TV.\",\n    \"6\": \"I like to eat fruits and vegetables.\",\n    \"7\": \"I don't read much.\",\n    \"8\": \"I want to cook healthy and tasty recipes for my family.\",\n    \"9\": \"I am on a diet and prefer low-calorie food.\",\n    \"10\": \"I want to know about the nutritional value of the ingredients I use.\",\n    \"11\": \"I'm looking for a new TV to replace my current one.\",\n    \"12\": \"I want a TV that is okay for light and size of my living room.\"\n}\nnum_ptkb = 3\n</code></pre> <pre><code>from sentence_transformers import CrossEncoder\nreranker = CrossEncoder('cross-encoder/ms-marco-MiniLM-L-6-v2')\nptkb_statements = get_ptkb_statements(query, num_ptkb, ptkb, reranker)\nptkb_statements\n</code></pre>"},{"location":"demo/#question-2-how-do-we-use-these-relevant-ptkb-statements","title":"Question 2: How do we use these relevant PTKB statements?","text":"<p>One possible way of using these relevant PTKB statements is to include them in the context when re-writing the query.</p> <p>Let's see how that works. We will modify out previous function <code>extract_context</code> a little to include the relevant PTKB statements.</p> <pre><code>def extract_context_with_ptkb_statements(json_data, number, turn_id, ptkb_statements):\n    # Find the correct dictionary with the given number\n    data = None\n    for item in json_data:\n        if item['number'] == number:\n            data = item\n            break\n\n    # If we couldn't find the data for the given number\n    if not data:\n        print(\"No data found for the given number.\")\n        return \"No data found for the given number.\"\n\n    # Extract the utterance and response values\n    texts = [ptkb_statements]\n    current_utterance = \"\"\n    for turn in data['turns']:\n        if turn['turn_id'] &lt; turn_id:\n            texts.append(turn['utterance'])\n            texts.append(turn['response'])\n        elif turn['turn_id'] == turn_id:\n            current_utterance = turn['utterance']\n            texts.append(current_utterance)\n\n    # Join the texts with \"|||\" separator\n    context = '|||'.join(texts)\n\n    return current_utterance, context\n</code></pre> <pre><code>number_to_search = \"10-1\"\nturn_id_to_search = 6\nutterance, context = extract_context_with_ptkb_statements(topics, number_to_search, turn_id_to_search, ptkb_statements)\nprint(f\"Raw Utterance: {utterance}\")\nprint(f\"Turn Context: {context}\")\n</code></pre> <pre><code>rewrite = rewrite_query(context, rewriter, rewriter_tokenizer, device)\nprint(f\"Query Rewrite: {rewrite}\")\n</code></pre> <p>That didn't help either! \ud83d\ude1e</p> <p>This is a really difficult query for the system! We are excited \ud83e\udd29 to see how your system handles such queries.</p> <p>Alternatively, we can also append the PTKB statements to the rewritten query (without PTKB statements).</p>"},{"location":"demo/#passage-retrieval-and-reranking","title":"Passage Retrieval and Reranking","text":"<p>In iKAT 2023, we provide several tasks, see the guidelines section of the webpage for more details.</p> <p>One core task in iKAT 2023 involves producing a ranked list of relevant passages corresponding to a specific user utterance. During the Passage Retrieval phase, we employ the rephrased query (either manually or automatically adjusted) to fetch a potential set of passages from the previously generated sparse index.</p> <p>The retrieve-then-rerank approach is a widely adopted strategy in Information Retrieval systems, aimed at enhancing the quality of the preliminary set of candidates. The process commences with a swift and effective retrieval method to fetch the initial set of passages. One prevalent method for this is BM25. However, there's also the option of adopting dense retrieval methods like Bi-encoders. For a comprehensive understanding of utilizing bi-encoders in retrieval, consider checking this guide.</p> <p>Subsequent to this initial retrieval, the candidate set undergoes a reranking process, leveraging more advanced methods. An example would be rerankers rooted in BERT, known as cross-encoders. In this tutorial, we'll specifically employ the <code>CrossEncoder</code> from the <code>SentenceTransformers</code> library.</p>"},{"location":"demo/#step-1-retrieval-using-bm25","title":"Step-1: Retrieval using BM25","text":"<p>We will first retrieve a candidate set of passages from our index using BM25. As query, we will use the manually resolved utterance from <code>turn_id=6</code> in the example shown above.</p> <pre><code>def retrieve_using_bm25(query):\n    hits = searcher.search(query)\n    candidate_set = []\n    for i in range(len(hits)):\n        print('Rank: {} | PassageID: {} | Score: {}'.format(i+1, hits[i].docid, hits[i].score))\n        doc = searcher.doc(hits[i].docid)\n        parsed_doc = json.loads(doc.raw())\n        print(parsed_doc['contents'])\n        candidate_set.append({\n            'passage_id': hits[i].docid,\n            'bm25_rank': i+1,\n            'bm25_score': hits[i].score,\n            'passage_text': parsed_doc['contents']\n        })\n        print('=================================')\n    return candidate_set\n</code></pre>"},{"location":"demo/#step-2-rerank-using-crossencoder","title":"Step-2: Rerank using CrossEncoder","text":"<p>Next, we will rerank this candidate set using the <code>CrossEncoder</code> defined earlier.</p> <pre><code>def rerank_passages(query, passages, reranker):\n    res = []\n    query_passage_pairs = [[query, passage['passage_text']] for passage in passages]\n    scores = reranker.predict(query_passage_pairs)\n\n    for passage, score in zip(passages, scores):\n        passage['reranker_score'] = score\n        res.append(passage)\n\n    ranked_passages = sorted(passages, key=lambda x: x['reranker_score'], reverse=True)\n    return ranked_passages\n</code></pre> <pre><code>query = \"Can you compare mozzarella with plant-based cheese?\"\ncandidate_set = retrieve_using_bm25(query)\n</code></pre> <pre><code>import numpy as np\nreranked_passages = rerank_passages(query, candidate_set, reranker)\nprint(json.dumps(reranked_passages, indent=4, default=lambda o: float(o) if isinstance(o, np.float32) else o))\n</code></pre> <p>These results are not great. An important thing to note here is that we are doing retrieval over a very small corpus of <code>SimpleEnglishWikipedia</code>. As mentioned earlier, the results may not be of high quality.</p>"},{"location":"demo/#response-generation","title":"Response Generation","text":"<p>One of the tasks in iKAT 2023 is response generation. After retrieval, the system should use the top-K passages to generate a short response (250 words or less) that is appropriate for an interactive conversational agent to give to the user.</p> <p>Let's explore one way this can be done, by framing the task as a summarisation problem. We will use the <code>T5</code> model for this purpose. Specifically, we will use the <code>mrm8488/t5-base-finetuned-summarize-news</code> model from HuggingFace.</p> <p>The <code>mrm8488/t5-base-finetuned-summarize-news</code> is Google's <code>T5-base</code> model fine-tuned on the News Summary dataset for the downstream task of summarization.</p> <p>First, we will write a short function for this task.</p> <p>The <code>generate_response</code> function is described below:</p> <ol> <li> <p>Purpose: Generates a summarized response based on the top passages from a set of documents returned by a search operation.</p> </li> <li> <p>Parameters:</p> <ul> <li><code>passages</code>: A set of top documents or hits returned by the search operation.</li> <li><code>model</code>: An instance of a pre-trained sequence-to-sequence language model (from the <code>AutoModelForSeq2SeqLM</code> class) for generating summaries.</li> <li><code>tokenizer</code>: An instance of a tokenizer (from the <code>AutoTokenizer</code> class) used to tokenize and decode text.</li> </ul> </li> <li> <p>Process:</p> <p>a. Consolidating Passages: Combines all the extracted passages into one continuous string.</p> <p>b. Tokenization and Input Formation: Tokenizes the combined text and pre-processes it by adding a \"summarize: \" prefix. The tokenized input is adjusted to not exceed a specified maximum length (512 tokens) and is moved to the desired computation device.</p> <p>c. Generating Summary: Utilizes the sequence-to-sequence language model to generate a summarized response based on the input. Applies various parameters to control and improve the quality of the output summary.</p> <p>d. Decoding the Summary: Transforms the token IDs from the generated summary back into human-readable text, ensuring any special tokens are omitted.</p> </li> <li> <p>Output: Returns a coherent and summarized text derived from the top passages of the documents.</p> </li> </ol> <pre><code>def generate_response(passages, model, tokenizer):\n    text = ' '.join(passages)\n    inputs = tokenizer.encode(\"summarize: \" + text, return_tensors=\"pt\", max_length=512, truncation=True)\n    with torch.no_grad():\n        summary_ids = model.generate(\n            inputs,\n            max_length=250,\n            min_length=50,\n            length_penalty=2.0,\n            num_beams=4,\n            early_stopping=True\n        )\n    summary = tokenizer.decode(summary_ids[0], skip_special_tokens=True)\n    return summary\n</code></pre> <pre><code>summarizer = AutoModelForSeq2SeqLM.from_pretrained('mrm8488/t5-base-finetuned-summarize-news')\nsummarizer_tokenizer = AutoTokenizer.from_pretrained('mrm8488/t5-base-finetuned-summarize-news')\n</code></pre> <pre><code># We use the top-3 reranked passages to generate a response\npassages = [passage['passage_text'] for passage in reranked_passages][:3]\nprint(json.dumps(passages, indent=4))\n</code></pre> <pre><code>generate_response(passages, summarizer, summarizer_tokenizer)\n</code></pre>"},{"location":"guidelines/","title":"Guidelines for the task","text":"<p>The guidelines are also available as a Google Doc.</p>"},{"location":"guidelines/#participation","title":"Participation","text":"<p>Participants must register to submit. To request a late registration, please email trec@nist.gov requesting a registration key. The dissemination form must be returned to submit runs.</p>"},{"location":"guidelines/#track-overview","title":"Track Overview","text":"<p>In iKAT, the direction of the conversation can be changed in each turn based on:</p> <ol> <li> <p>The previous response from the user, and\u00a0</p> </li> <li> <p>The information learned from the user (background, perspective, and context).\u00a0</p> </li> </ol> <p>The persona of the user and their information needs form the direction of the conversation. Each topic will have multiple  conversations based on multiple personas and results in different outputs that demonstrates the personalized aspect of the conversations. To this aim, the persona and the information needs of the user are modeled by generating a Personal Textual Knowledge Base (PTKB) during the conversation.\u00a0</p> <p>Note: In the first year, the PTKB is provided for each conversation and the participants do not have to generate or update it.</p>"},{"location":"guidelines/#task-overview","title":"Task Overview","text":"<p>In Year 1, the input at each conversation turn that is provided to the participants is the following:\u00a0</p> <ol> <li> <p>Current user's information need</p> </li> <li> <p>Conversation history</p> </li> <li> <p>Personal Text Knowledge Base (PTKB).</p> </li> </ol> <p>We offer the following tasks:</p> <ul> <li> <p>Passage Ranking: Retrieve and rank relevant passages from the given collection in response to a user utterance.\u00a0</p> </li> <li> <p>Response Generation: For each turn, return a series of text responses. Each response may be simply a passage from the collection. Alternatively, it may also be an extracted or generated summary from one or more passage results. All responses must have at least one passage called \"provenance\" from the collection.</p> </li> <li> <p>PTKB Statement Ranking: The relevant statements from PTKB are to be determined by the system in each turn. We approach this task as a relevance score prediction task. So, this output is in the form of a sorted list of the statements from PTKB with corresponding relevance score.</p> </li> </ul> <p>We plan on providing baseline ranking and response generation methods.\u00a0</p>"},{"location":"guidelines/#submission-classes","title":"Submission Classes","text":"<p>There are two submission classes:</p> <ul> <li> <p>Automatic: No manually labeled data can be used for this run type. This means that the models should solely rely on the current utterance, and the converation context (i.e., previous user utterance and system\u2019s canonical responses). Moreover, systems should not use the <code>ptkb_provenance</code> fields from the current or previous turns. They should have a module to automatically identify the relevant PTKB statements (for an example, see the <code>Getting Started</code> part of the website).</p> </li> <li> <p>Manual: The manual runs can use the manually annotated data in the models. This includes the following: </p> <ol> <li>The manual rewritten utterance of the current utterance</li> <li>The ground-truth relevant PTKB statements (<code>ptkb_provenance</code>) of the current utterance</li> <li>The ground-truth relevant PTKB statements (<code>ptkb_provenance</code>) of previous turns.</li> </ol> </li> </ul> <p>Note. In either run type, the participants are not allowed to use any information from the future. In other words, you should assume that for each turn, the only available information is up and including the current user utterance -- the system reponse of the current turn, as well as anything beyond that are hidden.</p> <p>In the submission form, we will ask the pariticpants to mark which data sources they used in the manual submissions. You may either use some or all available lableled data, but this should be clearly specified in the run submission form.</p>"},{"location":"guidelines/#important-points-regarding-submissions","title":"Important Points Regarding Submissions","text":"<ul> <li> <p>Title of the topic cannot be used.</p> </li> <li> <p>The file <code>2023_top_1000_query_results.zip</code> provided on the \"Data and Resources\" page of this website is based on the manually rewritten queries. Teams may use them in their submission; however, please note that such submissions would be automaitcally considered as <code>manual</code>.</p> </li> </ul>"},{"location":"guidelines/#example-dialogue-tree","title":"Example Dialogue Tree","text":"<p>An example of two different conversations based on different personas for the same topic is shown in the following figure. For each user turn, systems should return a ranked list of text responses. Each response has one or more (ranked) source passages as provenance. In addition, the systems should provide a sorted list of relevant statements of PTKB with the corresponding relevance score.</p> <p></p> <p>For an explanation of the above diagram, see the Google Doc.</p>"},{"location":"guidelines/#primary-task-details","title":"Primary Task Details","text":"<p>The main task in iKAT can be defined as personalized retrieval-based \"candidate response retrieval\" in context of the conversation. The task can be divided into the following sub-tasks:</p> <ul> <li> <p>Read the current dialogue turns up to the given turn (context). The provided context is:\u00a0(1) A fixed set of previous responses with provenance in the preceding turns up to the current step, and (2) PTKB of the user. Note: Using information from following turns is not allowed.</p> </li> <li> <p>Find the relevant statements from PTKB to the information needed for this turn. This task is considered as a relevance score prediction. The output is in the form of a sorted list of the statements from PTKB with corresponding relevance score.</p> </li> <li> <p>Extract or generate a response. Each response can be generated from multiple passages. It can be an abstractive or extractive summary of the corresponding passages. Each response must have one or more ranked passages as provenance used to produce it.</p> </li> </ul>"},{"location":"guidelines/#what-is-a-response","title":"What is a response?","text":"<ul> <li> <p>A response is a text suitable for showing to the user. It should be fluent, satisfy their information needs, and not contain extraneous or redundant information.\u00a0</p> </li> <li> <p>A response is limited to a maximum of 250 words (as measured by the <code>Tokenizer</code> function of <code>spacy.tokenizer</code> in spaCy v3.3 library), but should vary depending on an appropriate query-response.</p> </li> </ul>"},{"location":"guidelines/#passage-provenance-ranking","title":"Passage (provenance) Ranking","text":"<ul> <li> <p>A \"run\" takes the provenance passages for all responses in response order. The first 1000 provenances for each turn will be ranked.\u00a0</p> </li> <li> <p>Because a response may have multiple source passages, the score of passages in the provenance list for a response is used to order passages in descending order.</p> </li> <li> <p>If a source passage occurs in multiple responses, it will be ranked by its first response.\u00a0</p> </li> <li> <p>Each provenance is written in the format doc_id:passage_id.</p> </li> </ul>"},{"location":"guidelines/#ptkb-statement-provenance-ranking","title":"PTKB Statement (provenance) Ranking","text":"<ul> <li> <p>A 'run' takes the provenance PTKB statements for all responses on which the system's response is based.</p> </li> <li> <p>Because a response may consider multiple PTKB statements, the score of statements in the provenance list for a response is used to order statements in descending order.</p> </li> <li> <p>Teams may decide to include non-relevant statements with very low scores or just remove them from the ranked list.</p> </li> </ul>"},{"location":"guidelines/#collection","title":"Collection","text":"<p>The text collection contains a subset of ClueWeb22-B documents, prepared by the organizers in collaboration with CMU. The goal is to retrieve passages from target open-domain text collections. Provenance must be provided from documents in the collection.\u00a0</p>"},{"location":"guidelines/#passage-segmentation","title":"Passage Segmentation","text":"<p>For assessment, we will judge provenance passages. We segment the documents in our collection into passages in a similar manner as done by the TREC Deep Learning track for segmenting MS MARCO documents into passages: First, each document is trimmed to 10k characters. Then a 10-sentence sliding window with a 5-sentence stride is used to generate the passages.\u00a0</p> <p>An example document with some passage segmentation is provided in TrecWeb format below for illustration purposes:</p> <p></p>"},{"location":"guidelines/#topic-format","title":"Topic Format","text":"<p>We will provide several sample topics with example baseline runs for validation and testing. Below is a sample topics file with two subtrees of the same topic. Subtrees are identified by topic and subtree ID,  i.e topic 1, subtree 2 is <code>1-2</code>. Also a <code>passage_provenance</code> field with a list of provenance passages and <code>ptkb_provenance</code> field with a list of provenance statements from PTKB, that are used for generating the response, are included. An example is shown below for illustrative purposes. </p> <pre><code>[\n  {\n    \"number\": \"1-1\",\n        \"title\": \"Finding a university\",\n        \"ptkb\": {\n            \"1\": \"I graduated from Tilburg university.\",\n            \"2\": \"I live in the Netherlands.\",\n            \"3\": \"I'm allergic to peanuts.\",\n            \"4\": \"I worked as a web developer for 2 years.\",\n            \"5\": \"I have a bachelor's degree in computer science.\",\n            \"6\": \"I like Indian food.\",\n            \"7\": \"My bachelor's GPA is 5.6.\",\n            \"8\": \"I'm 26 years old.\",\n            \"9\": \"My TOEFL SCORE is 91.\",\n            \"10\": \"My interesting bachelor courses are data structure, algorithm, data mining, and artificial intelligence.\",\n            \"11\": \"I didn't like computer architecture and logical circuits courses.\"\n        },\n        \"turns\": [\n            {\n                \"turn_id\": 1,\n                \"utterance\": \"I want to start my master's degree, can you help me with finding a university?\",\n                \"resolved_utterance\": \"I want to start my master's degree, can you help me with finding a university?\",\n                \"response\": \"Do you want to continue your bachelor's studies and obtain a degree in computer science?\",\n                \"ptkb_provenance\": [\n                    5\n                ],\n                \"response_provenance\": []\n            },\n            {\n                \"turn_id\": 2,\n                \"utterance\": \"Yes, I want to continue my studies in computer science.\",\n                \"resolved_utterance\": \"Yes, I want to continue my studies in computer science.\",\n                \"response\": \"Do you want to study in the Netherlands, Europe, or somewhere further away?\",\n                \"ptkb_provenance\": [\n                    2\n                ],\n                \"response_provenance\": []\n            },\n            {\n                \"turn_id\": 3,\n                \"utterance\": \"I'd like to stay here.\",\n                \"resolved_utterance\": \"I'd like to stay in the Netherlands.\",\n                \"response\": \"I can help you with finding a university for continuing your studies in the Netherlands as a computer science student. Take a look at these Top Computer Science Universities in the Netherlands: Delft University of Technology, Eindhoven University of Technology, Vrije Universiteit Amsterdam, University of Amsterdam, Leiden University, Radboud University, Utrecht University, University of Twente\",\n                \"ptkb_provenance\": [\n                    5,\n                    2\n                ],\n                \"response_provenance\": [\n                    \"clueweb22-en0034-09-03452:1\"\n                ]\n            },\n  }\n  {\n        \"number\": \"1-2\",\n        \"title\": \"Finding a university\",\n        \"ptkb\": {\n            \"1\": \"I don't like crazy cold weather.\",\n            \"2\": \"I don't have a driver's license.\",\n            \"3\": \"I plan to move to Canada.\",\n            \"4\": \"I'm from the Netherlands.\",\n            \"5\": \"I'm used to heavy rains in the Netherlands.\",\n            \"6\": \"I graduated from UvA.\",\n            \"7\": \"I have bachelor's degree in computer science.\",\n            \"8\": \"I speak English fluently.\"\n        },\n        \"turns\": [\n            {\n                \"turn_id\": 1,\n                \"utterance\": \"I want to start my master's degree, can you help me with finding a university?\",\n                \"resolved_utterance\": \"I want to start my master's degree, can you help me with finding a university in Canada?\",\n                \"response\": \"Sure, do you want to study computer science?\",\n                \"ptkb_provenance\": [\n                    7,\n                    3\n                ],\n                \"response_provenance\": []\n            },\n            {\n                \"turn_id\": 2,\n                \"utterance\": \"Yes, I want to pursue the same major. Can you tell me the name of the best universities?\",\n                \"resolved_utterance\": \"Yes, I want to pursue computer science. Can you tell me the name of the best computer science universities in Canada?\",\n                \"response\": \"Here are the top universities for computer science in Canada: 1) University of British Columbia, 2) University of Alberta, 3)Concordia University, 4) Simon Fraser University, 5)The University of Toronto\",\n                \"ptkb_provenance\": [],\n                \"response_provenance\": [\n                    \"clueweb22-en0026-31-15538:1\",\n                    \"clueweb22-en0026-31-15538:4\",\n                    \"clueweb22-en0026-31-15538:6\",\n                    \"clueweb22-en0040-41-06056:0\"\n                ]\n            },\n            {\n                \"turn_id\": 3,\n                \"utterance\": \"Which of them best suits me in terms of weather conditions?\",\n                \"resolved_utterance\": \"Which of the following universities best suits me in terms of weather conditions? 1) the University of British Columbia, 2) the University of Alberta, 3)Concordia University, 4) Simon Fraser University, and 5)The University of Toronto.\",\n                \"response\": \"I know you don't like very cold weather, but can you give me an estimation of the temperature that is acceptable for you?\",\n                \"ptkb_provenance\": [\n                    1,\n                    5\n                ],\n                \"response_provenance\": []\n            },\n  }\n]\n\n\n\n\n</code></pre>"},{"location":"guidelines/#task-submissions","title":"Task Submissions","text":"<p>Participants submit the output of their system on the specified \u201ctest\u201d topics.  A single participant may submit the output of multiple systems, up to a maximum of four runs. A sample run is provided below:</p> <pre><code>{\n  \"run_name\": \"sample_run\",\n  \"run_type\": \"automatic\",\n  \"turns\": [\n    {\n      \"turn_id\": \"1-2_3\",\n      \"responses\": [\n        {\n          \"rank\": 1,\n          \"text\": \"The University of British columbia in Vancouver has temperatures near 80 degrees Fahrenheit (27 degrees Celsius) in summer and up to 45 degrees Fahrenheit (about \ndegrees Celsius) in winter which is suitable for you. The university of Toronto is acceptable since has cold winters, average temperatures can drop below -10 \u00b0 C but not below 12 degrees for long. The Concordia university in Montreal is not suitable for you since in the winter, could reach minus 40 with the wind chill. University of Alberta is also not suitable for you. In winter the average temperature varies between -6.5\u00b0C (20.3\u00b0F) and -13.5\u00b0C (7.7\u00b0F). Simon Fraser university is not acceptable for you. The city which the university is located in will reach temperatures of -14 in the winter.\",\n          \"ptkb_provenance\": [\n            {\n              \"id\": \"1\",\n              \"text\": \"I cannot withstand the temperature below -12 for long time\",\n              \"score\": 0.9\n            },\n            {\n              \"id\": \"2\",\n              \"text\": \"I\u2019m used to heavy rains in the Netherlands\",\n              \"score\": 0.8\n            }\n          ],\n          \"passage_provenance\": [\n            {\n              \"id\": \"clueweb22-en0000-94-02275:0\",\n              \"text\": \"...\",\n              \"score\": 0.6\n            },\n            {\n              \"id\": \"clueweb22-en0027-06-08704:1\",\n              \"text\": \"...\",\n              \"score\": 0.5\n            },\n            {\n              \"id\": \"clueweb22-en0005-63-12144:0\",\n              \"text\": \"...\",\n              \"score\": 0.4\n            },\n            {\n              \"id\": \"clueweb22-en0013-01-17558:1\",\n              \"text\": \"...\",\n              \"score\": 0.38\n            },\n            {\n              \"id\": \"clueweb22-en0014-39-04143:0\",\n             \"text\": \"...\",\n              \"score\": 0.3\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <ol> <li>The run_name is a run submission identifier that should be descriptive and unique to your team and institution.</li> <li>The run_type is one of the two types listed above, automatic and manual.</li> <li>Each turn in the turns list should contain a turn_identifier, consisting of the topic_id-subtree_id and turn_id concatenated with an underscore, e.g. <code>1-2_3</code> for topic 1, subtree 2, turn 3.</li> <li>Each turn should also contain a list of responses. A response consists of text and a provenance list. Each provenance should have an id, text, and score.</li> <li>Each turn includes a sorted list of statements from PTKB based on the relevance score of each statement from PTKB to the current turn.</li> </ol> <p>For provenance ranking, this will be converted to a traditional TREC run format:</p> <p><code>31_1-1 Q0 clueweb22-en0000-94-02275:0 1 0.5 sample_run</code></p> <p>Runs may include up to 1000 responses for each user turn. For provenance ranking, only the first 1000 pieces of unique provenance will be used. As in previous years of CAsT, only a limited top-K responses and provenances will be assessed according to resource constraints. </p>"},{"location":"guidelines/#evaluation","title":"Evaluation","text":"<p>We will use the relevance assessment methods used in previous years of CAsT for relevance to individual turns.</p> <ol> <li>Provenance Passage Assessment: The provenance passages that are used to produce the responses will be pooled and assessed. The relevance scale will be the same as previous years of CAsT, see the previous overview papers for details. The standard ranking metrics such as P@k, NDCG@k, and MAP will be calculated using the judgments. We will focus on the earlier positions (1, 3, 5).</li> <li>Response Assessment: A response may be a simple passage or a summary of one or more passages in providing a response. We will assess the top ranked response (or top-k) from all systems for all turns. Only responses with at least one relevant provenance passage will be judged. Responses will be assessed for relevance and conciseness. The responses and judgments on them will be released with the judgments. </li> <li>Extracted Relevant Statements Assessment: The standard metrics like Precision, Recall, P@k, and MAP will be used for evaluating the sorted list of relevant statements from PTKB.</li> </ol> <p>Similar to CAsT year 4, only a subset of turns may be evaluated for provenance ranking effectiveness. This will be disclosed to participants after assessment is completed.</p>"},{"location":"guidelines/#timeline","title":"Timeline","text":"Task Date Guidelines released April 2023 Test topics released June 2023 Submission deadline August 31, 2023 Results released to participants October 2023"}]}